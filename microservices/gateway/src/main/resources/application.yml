server:
  port: 8080
  netty:
    connection-timeout: 30s
    idle-timeout: 60s
  http2:
    enabled: true

spring:
  application:
    name: api-gateway

  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}

  main:
    web-application-type: reactive
    allow-bean-definition-overriding: true

  cloud:
    gateway:
      httpclient:
        pool:
          type: elastic
          max-connections: 10000
          max-idle-time: 30s
          max-life-time: 60s
          eviction-interval: 5s
        connect-timeout: 5000
        response-timeout: 30s
        wiretap: false
        compression: true

      # Global CORS Configuration
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins:
              - "http://localhost:3000"
              - "https://*.yourdomain.com"
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
              - PATCH
              - OPTIONS
            allowedHeaders: "*"
            allowCredentials: true
            maxAge: 3600

      # Default filters applied to all routes
      default-filters:
        - name: AddRequestHeader
          args:
            name: X-Request-Gateway
            value: api-gateway

        - name: AddResponseHeader
          args:
            name: X-Response-Gateway
            value: api-gateway

        - name: RemoveRequestHeader
          args:
            name: Cookie

        - name: CircuitBreaker
          args:
            name: defaultCircuitBreaker
            fallbackUri: forward:/fallback

        - name: Retry
          args:
            retries: 3
            methods: GET
            series: SERVER_ERROR
            exceptions:
              - java.net.ConnectException
              - java.io.IOException
            backoff:
              firstBackoff: 100ms
              maxBackoff: 500ms
              factor: 2
              basedOnPreviousValue: true

        - name: RequestSize
          args:
            maxSize: 10MB

      # Route definitions
      routes:
        # IAM Service - Authentication & Authorization
        - id: iam-auth
          uri: lb://iam-service
          predicates:
            - Path=/api/v1/auth/**
          filters:
            - RewritePath=/api/v1/auth/(?<segment>.*), /api/auth/${segment}
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 500
                redis-rate-limiter.burstCapacity: 1000
                redis-rate-limiter.requestedTokens: 1
            - name: CircuitBreaker
              args:
                name: iamCircuitBreaker
                fallbackUri: forward:/fallback/auth

        # IAM Service - User Management (Protected)
        - id: iam-users
          uri: lb://iam-service
          predicates:
            - Path=/api/v1/users/**
          filters:
            - RewritePath=/api/v1/users/(?<segment>.*), /api/users/${segment}
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 1000
                redis-rate-limiter.burstCapacity: 2000

        # Organization Service (will be implemented in Phase 2)
        - id: organization-service
          uri: lb://crm-monolith
          predicates:
            - Path=/api/v1/organizations/**, /api/v1/branches/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 1000
                redis-rate-limiter.burstCapacity: 2000

        # Customer Service (will be implemented in Phase 2)
        - id: customer-service
          uri: lb://crm-monolith
          predicates:
            - Path=/api/v1/customers/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 2000
                redis-rate-limiter.burstCapacity: 4000
            - name: CacheResponse
              args:
                ttl: 60s

        # Default route to monolith
        - id: default-monolith
          uri: lb://crm-monolith
          predicates:
            - Path=/api/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 1000
                redis-rate-limiter.burstCapacity: 2000

      # Service Discovery
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true

  # Redis Configuration (Cluster mode for high availability)
  data:
    redis:
      cluster:
        nodes:
          - ${REDIS_NODE_1:localhost:6379}
          - ${REDIS_NODE_2:localhost:6380}
          - ${REDIS_NODE_3:localhost:6381}
        max-redirects: 3
      password: ${REDIS_PASSWORD:}
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 500
          max-idle: 50
          min-idle: 10
          max-wait: 2000ms
        shutdown-timeout: 100ms

  # Security Configuration
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${KEYCLOAK_ISSUER_URI:http://localhost:8180/realms/crm}
          jwk-set-uri: ${KEYCLOAK_JWK_SET_URI:http://localhost:8180/realms/crm/protocol/openid-connect/certs}
          audiences:
            - crm-frontend
            - crm-backend

# Resilience4j Configuration
resilience4j:
  circuitbreaker:
    configs:
      default:
        slidingWindowSize: 100
        minimumNumberOfCalls: 10
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
        permittedNumberOfCallsInHalfOpenState: 5
        automaticTransitionFromOpenToHalfOpenEnabled: true
        recordExceptions:
          - org.springframework.web.client.HttpServerErrorException
          - java.util.concurrent.TimeoutException
          - java.net.ConnectException
    instances:
      defaultCircuitBreaker:
        baseConfig: default
      iamCircuitBreaker:
        baseConfig: default
        failureRateThreshold: 30
        waitDurationInOpenState: 5s

  ratelimiter:
    configs:
      default:
        limitForPeriod: 1000
        limitRefreshPeriod: 1s
        timeoutDuration: 100ms

  timelimiter:
    configs:
      default:
        timeoutDuration: 30s
        cancelRunningFuture: true

  bulkhead:
    configs:
      default:
        maxConcurrentCalls: 100
        maxWaitDuration: 10ms

# Management & Monitoring
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,gateway,refresh
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
      probes:
        enabled: true
    gateway:
      enabled: true
  health:
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
        step: 10s
    distribution:
      percentiles-histogram:
        http.server.requests: true
      percentiles:
        http.server.requests: 0.5,0.95,0.99
    tags:
      application: ${spring.application.name}
  tracing:
    sampling:
      probability: ${TRACING_PROBABILITY:0.1}

# Logging Configuration
logging:
  level:
    root: INFO
    com.neobrutalism.crm.gateway: DEBUG
    org.springframework.cloud.gateway: DEBUG
    org.springframework.security: INFO
    org.springframework.web.reactive: INFO
    reactor.netty: INFO
    io.lettuce: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg - traceId=%X{traceId} spanId=%X{spanId}%n"

# Application-specific Configuration
app:
  gateway:
    routing:
      strategy: ${ROUTING_STRATEGY:monolith}
      canary:
        enabled: ${CANARY_ENABLED:false}
    cors:
      allowed-origin-patterns: ${CORS_ALLOWED_ORIGINS:http://localhost:3000,https://*.yourdomain.com}
    cache:
      jwt-validation:
        ttl: 60
        max-size: 100000
      permission-check:
        ttl: 60
        max-size: 50000
    security:
      jwt:
        cache-enabled: true
        cache-size: 100000
        cache-ttl-seconds: 300
