# IAM Service - Enterprise Production Configuration
# Optimized for 100K+ concurrent users with JWT preloading

spring:
  application:
    name: iam-service-enterprise

  # R2DBC Configuration - High Performance
  r2dbc:
    url: r2dbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    pool:
      initial-size: 50  # Higher initial pool
      max-size: 500  # Support high concurrency
      max-idle-time: 60m
      max-acquire-time: 5s
      max-create-connection-time: 10s
      validation-query: SELECT 1

  # Redis Configuration - High Performance
  data:
    redis:
      cluster:
        nodes:
          - redis-node-1:6379
          - redis-node-2:6379
          - redis-node-3:6379
          - redis-node-4:6379
          - redis-node-5:6379
          - redis-node-6:6379
        max-redirects: 3
      password: ${REDIS_PASSWORD}
      timeout: 500ms  # Reduced for faster failover
      lettuce:
        pool:
          max-active: 1000  # Higher for cache operations
          max-idle: 200
          min-idle: 50
          max-wait: 500ms
        shutdown-timeout: 100ms
        cluster:
          refresh:
            adaptive: true
            period: 30s

# Permission Cache Configuration - Enterprise
permission:
  cache:
    l1:
      max-size: 500000  # 500K permission checks in memory
      ttl-seconds: 300  # 5 minutes
      refresh-after-write-seconds: 120  # Refresh hot entries
    l2:
      ttl-seconds: 600  # 10 minutes in Redis
    materialized-view:
      refresh-strategy: incremental
      refresh-interval-seconds: 60

# JWT Configuration - With Permission Preloading
app:
  iam:
    jwt:
      issuer: neobrutalism-iam-enterprise
      access-token-validity-seconds: 900  # 15 minutes
      refresh-token-validity-seconds: 604800  # 7 days
      permission-compression-enabled: true  # Enable compression
      max-token-size-kb: 8  # Limit token size to 8KB

    permission:
      cache-enabled: true
      sync-to-redis: true
      bloom-filter-enabled: true
      preload-in-jwt: true  # KEY FEATURE: Preload permissions in JWT

    rate-limit:
      enabled: true
      requests-per-second: 10000  # 10K RPS per instance

    # Cache Invalidation Configuration
    cache-invalidation:
      enabled: true
      redis-pubsub-enabled: true
      channels:
        - cache:invalidation
        - cache:permission:change
        - cache:user:change
        - cache:tenant:change

  # JWT Key Management Configuration - PRODUCTION
  security:
    jwt:
      # Production: NEVER auto-generate keys (security risk)
      key-generation-enabled: false

      # Load keys from Kubernetes Secret mounted volume
      # kubectl create secret generic jwt-keypair \
      #   --from-file=private_key.pem=./private_key.pem \
      #   --from-file=public_key.pem=./public_key.pem \
      #   -n neobrutalism-crm
      #
      # Then mount to /etc/jwt-keys in deployment.yaml
      private-key-path: file:/etc/jwt-keys/private_key.pem
      public-key-path: file:/etc/jwt-keys/public_key.pem

      issuer: neobrutalism-crm-enterprise
      access-token-validity-seconds: 900  # 15 minutes

  # Scheduler Configuration - ENTERPRISE (100K CCU)
  scheduler:
    # Casbin worker pool: 100 threads for 100K CCU
    # Calculation: 100K users × 10 req/min = 16.6K RPS
    #              16.6K RPS × 5ms latency × 2% cache miss = 1.66 threads
    #              Safety margin: 100 threads (60x headroom)
    casbin-pool-size: 100
    # DB worker pool: 50 threads for blocking DB ops
    db-pool-size: 50

# Casbin Configuration - Performance
casbin:
  model-path: classpath:casbin/model.conf
  policy-adapter: database
  auto-save: true
  batch-size: 1000  # Batch policy updates
  watcher:
    enabled: true
    channel: casbin-policy-updates
    redis-enabled: true

# Management & Monitoring - Enterprise
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,refresh,caches,env
  endpoint:
    health:
      show-details: always
      probes:
        enabled: true
  health:
    redis:
      enabled: true
    db:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
        step: 5s
    distribution:
      percentiles-histogram:
        http.server.requests: true
      percentiles:
        http.server.requests: 0.5,0.9,0.95,0.99,0.999
      slo:
        http.server.requests: 1ms,5ms,10ms,50ms,100ms
    tags:
      application: ${spring.application.name}
      environment: production
  tracing:
    sampling:
      probability: 0.001  # 0.1% sampling

# Logging - Production
logging:
  level:
    root: WARN
    com.neobrutalism.crm.iam: INFO
    com.neobrutalism.crm.iam.service: INFO
    org.casbin: WARN
    org.springframework.r2dbc: WARN
    io.r2dbc.postgresql: WARN
    io.lettuce: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg - traceId=%X{traceId} spanId=%X{spanId}%n"

# Server Configuration
server:
  port: 8081
  netty:
    connection-timeout: 10s
    idle-timeout: 120s

# Resilience Configuration
resilience4j:
  circuitbreaker:
    configs:
      default:
        slidingWindowSize: 1000
        minimumNumberOfCalls: 50
        failureRateThreshold: 20
        waitDurationInOpenState: 15s

  bulkhead:
    configs:
      default:
        maxConcurrentCalls: 1000
        maxWaitDuration: 5ms

# JVM Configuration Recommendations
# -Xms2g -Xmx2g
# -XX:+UseG1GC
# -XX:MaxGCPauseMillis=200
# -XX:+UseStringDeduplication
# -Dreactor.netty.ioWorkerCount=8
