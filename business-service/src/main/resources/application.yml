spring:
  application:
    name: business-service

  profiles:
    active: dev  # Default to dev profile (H2)

  # Consul Service Discovery
  cloud:
    consul:
      host: ${CONSUL_HOST:localhost}
      port: ${CONSUL_PORT:8500}
      discovery:
        enabled: true
        health-check-interval: 10s
        health-check-critical-timeout: 30s
        instance-id: ${spring.application.name}-${spring.cloud.client.ip-address}-${server.port}
        prefer-ip-address: true
        tags:
          - business
          - api

  # ✅ FIX: Configure multipart file upload to write directly to disk (prevent memory leak)
  servlet:
    multipart:
      enabled: true
      max-file-size: 100MB           # Maximum file size per file
      max-request-size: 100MB        # Maximum request size
      file-size-threshold: 0         # ✅ CRITICAL: Write ALL files to disk immediately, never buffer in memory
      location: ${java.io.tmpdir}    # Temporary directory for multipart files

  datasource:
    hikari:
      maximum-pool-size: 30              # ✅ Increased for parallel sheet processing
      minimum-idle: 10                   # ✅ Keep connections ready
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000    # Detect connection leaks
      # ✅ Performance tuning for batch operations
      data-source-properties:
        cachePrepStmts: true
        prepStmtCacheSize: 500           # ✅ Increased cache size
        prepStmtCacheSqlLimit: 2048
        useServerPrepStmts: true
        rewriteBatchedStatements: true   # ✅ CRITICAL: Batch multiple inserts into single statement
        maintainTimeStats: false         # ✅ Disable for performance
        useLocalSessionState: true       # ✅ Reduce round trips
        cacheResultSetMetadata: true     # ✅ Cache metadata
        cacheServerConfiguration: true   # ✅ Cache server config
        elideSetAutoCommits: true        # ✅ Reduce autocommit calls

  jpa:
    hibernate:
      ddl-auto: none
    show-sql: false
    properties:
      hibernate:
        format_sql: false
        enable_lazy_load_no_trans: false
        # Query Performance Monitoring - Disabled to reduce logging
        generate_statistics: false
        # ✅ JDBC Batch Insert Configuration - Critical for migration performance
        jdbc:
          batch_size: 1000                    # Batch 1000 records per round trip
          fetch_size: 1000                    # Fetch 1000 records at once
          batch_versioned_data: true          # Enable batch for versioned entities
        order_inserts: true                   # Order inserts for better batching
        order_updates: true                   # Order updates for better batching
        # ✅ FIX: Enable L2 cache and query cache
        cache:
          use_second_level_cache: true
          use_query_cache: true
          region:
            factory_class: org.hibernate.cache.jcache.JCacheRegionFactory
        session:
          events:
            log:
              LOG_QUERIES_SLOWER_THAN_MS: 1000
    open-in-view: false

  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true
    validate-on-migrate: true

  # Redis Configuration
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      timeout: 60000
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
          max-wait: -1ms
        shutdown-timeout: 100ms

  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

  # Email Configuration
  mail:
    host: ${MAIL_HOST:localhost}
    port: ${MAIL_PORT:1025}
    username: ${MAIL_USERNAME:}
    password: ${MAIL_PASSWORD:}
    properties:
      mail:
        smtp:
          auth: ${MAIL_SMTP_AUTH:false}
          starttls:
            enable: ${MAIL_SMTP_STARTTLS_ENABLE:false}
            required: ${MAIL_SMTP_STARTTLS_REQUIRED:false}
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000
    # From address configuration
    default-encoding: UTF-8
    
# Application-specific notification settings
notification:
  email:
    from: ${MAIL_FROM:noreply@crm.local}
    from-name: ${MAIL_FROM_NAME:Neobrutalism CRM}
    enabled: ${NOTIFICATION_EMAIL_ENABLED:true}
    quiet-hours:
      enabled: ${NOTIFICATION_QUIET_HOURS_ENABLED:false}
      start: ${NOTIFICATION_QUIET_HOURS_START:22}  # 10 PM
      end: ${NOTIFICATION_QUIET_HOURS_END:7}      # 7 AM
      timezone: ${NOTIFICATION_TIMEZONE:Asia/Ho_Chi_Minh}
    digest:
      enabled: ${NOTIFICATION_DIGEST_ENABLED:false}
      schedule: "0 0 8 * * ?"  # 8 AM daily
      max-age-hours: 24

server:
  port: ${SERVER_PORT:8081}  # Default 8081, gateway runs on 8080
  error:
    include-message: always
    include-binding-errors: always

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
    tags-sorter: alpha
    operations-sorter: alpha
    enabled: true
    try-it-out-enabled: true
  show-actuator: false

logging:
  level:
    root: INFO
    com.neobrutalism.crm: INFO
    org.springframework.web: INFO
    org.hibernate.SQL: WARN
    org.hibernate.type.descriptor.sql.BasicBinder: WARN
    org.hibernate.stat: WARN
    org.hibernate.engine.internal.StatisticalLoggingSessionEventListener: WARN

# Application specific properties
app:
  name: Neobrutalism CRM
  audit:
    enabled: true
  event-sourcing:
    enabled: true
  tenant:
    default-tenant-id: default  # Default tenant ID when no tenant context
    enabled: true               # Enable multi-tenancy
    header-name: X-Tenant-ID   # Tenant ID header name
    strict-mode: false         # false = use default tenant if missing, true = throw exception

# API Versioning Configuration
api:
  versioning:
    enabled: true
    default-version: v1
    current-version: v1
    deprecated-versions: {}  # Example: v0: { deprecation-date: "2024-12-01", sunset-date: "2025-06-01" }
    feature-flags: {}        # Example: v2.new-auth-flow: true

# Event publishing configuration
events:
  use-outbox: true  # Enable Transactional Outbox Pattern (recommended for production)

# Outbox publisher configuration
outbox:
  publisher:
    interval: 5000  # Publish pending events every 5 seconds
  cleanup:
    cron: "0 0 2 * * *"  # Cleanup old events daily at 2 AM

# Multi-tenancy configuration (deprecated - use app.tenant instead)
multitenancy:
  enabled: true  # Enable/disable multi-tenancy
  default-tenant: default  # Default tenant ID for development
  tenant-header: X-Tenant-ID  # HTTP header name for tenant ID

# JWT Configuration
jwt:
  secret: ${JWT_SECRET:neobrutalism-crm-secret-key-change-this-in-production-min-256-bits}
  access-token-validity: ${JWT_ACCESS_TOKEN_VALIDITY:3600000}
  refresh-token-validity: ${JWT_REFRESH_TOKEN_VALIDITY:604800000}
  max-refresh-tokens-per-user: 5

# Rate Limiting (✅ FIX: Enabled by default, disable explicitly in dev)
rate-limit:
  enabled: ${RATE_LIMIT_ENABLED:true}  # Default true, set to false in dev profile
  admin-limit: 1000    # Requests per minute for ADMIN role
  user-limit: 100      # Requests per minute for authenticated users
  public-limit: 20     # Requests per minute for public/unauthenticated

# MinIO Configuration
minio:
  endpoint: ${MINIO_ENDPOINT:http://localhost:9000}
  access-key: ${MINIO_ACCESS_KEY:minioadmin}
  secret-key: ${MINIO_SECRET_KEY:minioadmin}
  default-bucket: ${MINIO_DEFAULT_BUCKET:crm-files}

# File Upload Configuration
file:
  upload:
    max-size: 10485760  # 10MB in bytes

# Actuator configuration
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    export:
      prometheus:
        enabled: true
  tracing:
    sampling:
      probability: 0.1
  otlp:
    tracing:
      endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT:http://localhost:4318}

# ✅ Cache configuration for Hibernate L2 cache (merged with main spring config above)
#spring:
#  cache:
#    type: redis
#    redis:
#      time-to-live: 600000  # 10 minutes
#    cache-names:
#      - organizations
#      - users
#      - roles
#      - customer-stats
#      - contact-stats

# Casbin Authorization Cache Configuration
casbin:
  cache:
    enabled: true           # Enable Casbin built-in cache for permission checks
    max-size: 10000         # Maximum number of cached permission check results
    # Cache provides 10x-100x speedup for repeated permission checks
    # Memory overhead: ~1-2MB for 10,000 entries
    # Cache invalidation: Automatic when policies are added/removed/updated
    l1:
      enabled: true        # Enable L1 (Caffeine) in-memory cache
      max-size: 10000      # Maximum cache entries
      ttl-minutes: 10      # Cache entry TTL (Time To Live)
      # L1 cache provides additional ~10x-100x speedup on top of Casbin's built-in cache
      # Expected performance: ~0.001ms per check (~1,000,000 ops/sec)
